{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE ScopedTypeVariables       #-}

module Asyncly.Threads
    ( wait
    , wait_
    , gather

    , waitLogged
    , waitLogged_
    , logged
    , suspend
    , withLog
    , eachWithLog
    )
where

import           Control.Concurrent          (killThread)
import           Control.Concurrent.STM      (atomically, newTChan)
import           Control.Exception           (SomeException (..))
import           Control.Monad.Catch         (MonadCatch, throwM, try)
import           Control.Monad.IO.Class      (MonadIO (..))
import           Control.Monad.State         (get, mzero, put, runStateT)
import           Control.Monad.Trans.Class   (MonadTrans (lift))
import           Data.IORef                  (IORef, atomicModifyIORef,
                                              newIORef, readIORef)

import           Asyncly.AsyncT

------------------------------------------------------------------------------
-- Running the monad
------------------------------------------------------------------------------

-- | Run an 'AsyncT m' computation and collect the results generated by each
-- thread of the computation in a list.
waitAsync :: (MonadAsync m, MonadCatch m)
    => (a -> AsyncT m a) -> Maybe (IORef [Log]) -> AsyncT m a -> m ()
waitAsync finalizer lref m = do
    childChan  <- liftIO $ atomically newTChan
    pendingRef <- liftIO $ newIORef []
    credit     <- liftIO $ newIORef maxBound

    let ctx = initContext childChan pendingRef credit finalizer lref

    r <- try $ runStateT (runAsyncT $ m >>= finalizer) ctx

    case r of
        Left (exc :: SomeException) -> do
            liftIO $ readIORef pendingRef >>= mapM_ killThread
            throwM exc
        Right _ -> do
            e <- waitForChildren ctx
            case e of
                Just (exc :: SomeException) -> throwM exc
                Nothing -> return ()

-- TBD throttling of producer based on conumption rate.

-- | Invoked to store the result of the computation in the context and finish
-- the computation when the computation is done
gatherResult :: MonadAsync m => IORef [a] -> a -> AsyncT m a
gatherResult ref r = do
    liftIO $ atomicModifyIORef ref $ \rs -> (r : rs, ())
    mzero

gather :: (MonadAsync m, MonadCatch m) => AsyncT m a -> AsyncT m [a]
gather m = AsyncT $ do
    resultsRef <- liftIO $ newIORef []
    lift $ waitAsync (gatherResult resultsRef) Nothing m
    r <- liftIO $ readIORef resultsRef
    return $ Just r

-- | Run an 'AsyncT m' computation and collect the results generated by each
-- thread of the computation in a list.
wait :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m [a]
wait m = do
    resultsRef <- liftIO $ newIORef []
    waitAsync (gatherResult resultsRef) Nothing m
    liftIO $ readIORef resultsRef

-- | Run an 'AsyncT m' computation, wait for it to finish and discard the
-- results.
wait_ :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m ()
wait_ m = waitAsync (const mzero) Nothing m

------------------------------------------------------------------------------
-- Logging
------------------------------------------------------------------------------

logged :: (Loggable a, MonadAsync m) => AsyncT m a -> AsyncT m a
logged m = AsyncT $ do
    ctx <- get
    case journal ctx of
        -- no replay
        CtxLog ls [] ->
            case logsRef ctx of
                Nothing -> runAsyncT m
                Just _ -> do
                    put $ ctx {journal = CtxLog (Executing : ls) []}
                    runAndLogResult m

        -- replaying the log
        CtxLog ls (r:rs) -> do
        --    dbg $ "Replay: j: " ++ show j
            case r of
                Executing -> do
                    put $ ctx {journal = CtxLog (r : ls) rs}
                    runAndLogResult m
                Result val -> do
                    let x = fmap read val
                    put $ ctx {journal = CtxLog (r : ls) rs}
                    return x

    where

    runAndLogResult action = runAsyncT $ do
        x <- action
        logResult x
        return x

    -- replaces the head of the log with the supplied result
    logResult x = AsyncT $ do
        ctx@Context{journal = CtxLog (_ : ls) _} <- get
        let entry = Result (fmap show (Just x))
        put $ ctx {journal = CtxLog (entry : ls) []}
        return $ Just ()

-- XXX enable or disable the suspension points by sending an exception to the
-- computation.
--
-- | Suspend works as an exit point with current thread state (partially done)
-- saved. The computation exits only if all the threads in the computation hit
-- the suspend point or exit normally. The threads which hit the suspension and
-- were suspended can be re-started by replaying the log. If there are threads
-- which did not suspend or did not exit, the computation will not exit. For
-- completed threads output is returned and for suspended threads the logs to
-- resume them are returned.

suspend :: MonadAsync m => AsyncT m ()
suspend = logged $ AsyncT $ do
    ctx <- get
    case logsRef ctx of
        Nothing -> return $ Just ()
        Just ref ->
            case journal ctx of
                CtxLog ls [] -> do
                    -- replace the "Executing" entry at the head of the log
                    -- with a "()" so that we do not enter suspend on replay
                    liftIO $ atomicModifyIORef ref $ \logs ->
                        (Log (logResult (Just ()) : tail ls) : logs, ())
                    return Nothing
                _ -> error "Bug: replay inside suspend"
    where logResult x = Result (fmap show x)

-- | Compose a computation using previously captured logs
withLog :: Monad m => AsyncT m a -> Log -> AsyncT m a
withLog m (Log entries) = AsyncT $ do
    ctx <- get
    put $ ctx {journal = CtxLog [] (reverse entries)}
    runAsyncT m

-- | Compose a computation using previously captured list of logs. Composes a
-- group of computations, one for each log.
eachWithLog :: MonadAsync m => AsyncT m a -> [Log] -> AsyncT m a
eachWithLog m logs = each logs >>= withLog m

-- | Run an 'AsyncT m' computation with logging enabled and collect the results
-- or logs generated by each thread of the computation.
waitLogged :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m ([a], [Log])
waitLogged m = do
    resultsRef <- liftIO $ newIORef []
    lref <- liftIO $ newIORef []
    waitAsync (gatherResult resultsRef) (Just lref) m
    res <- liftIO $ readIORef resultsRef
    logs <- liftIO $ readIORef lref
    return (res, logs)

-- | Run an 'AsyncT m' computation with logging enabled, wait for it to finish
-- and discard the results. If the computation suspends collect the logs to
-- replay later.
waitLogged_ :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m [Log]
waitLogged_ m = do
    lref <- liftIO $ newIORef []
    waitAsync (const mzero) (Just lref) m
    logs <- liftIO $ readIORef lref
    return logs
