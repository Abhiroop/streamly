{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE UndecidableInstances #-}

-- |
-- Module      : Asyncly.Threads
-- Copyright   : (c) 2017 Harendra Kumar
--
-- License     : MIT-style
-- Maintainer  : harendra.kumar@gmail.com
-- Stability   : experimental
-- Portability : GHC
--
module Asyncly.RunAsync
    ( wait
    , wait_
    , AsynclyT
--    , threads
    , each
    {-
    , gather

    , waitRecord_
    , waitRecord
    , playRecordings
    -}
    )
where

import           Control.Applicative         (Alternative (..))
import           Control.Concurrent.STM      (atomically, newTChan)
import           Control.Monad               (liftM)
import           Control.Monad.Catch         (MonadCatch, MonadThrow, throwM, try)
import           Control.Monad.IO.Class      (MonadIO (..))
import           Control.Monad.Trans.Class   (MonadTrans (lift))
import           Control.Monad.Trans.Control (MonadBaseControl)
import           Control.Monad.State         (StateT, runStateT)
import           Control.Monad.Trans.Class   (MonadTrans (lift))
import           Data.Atomics                (atomicModifyIORefCAS)
import           Data.IORef                  (IORef, newIORef, readIORef)

import           Control.Monad.Trans.Recorder (MonadRecorder(..), RecorderT,
                                               Recording, blank, runRecorderT)
import           GHC.Prim                    (Any)

import           Asyncly.Threads
import           Asyncly.AsyncT

newtype AsynclyT m a = AsynclyT { runAsynclyT :: AsyncT (StateT Context m) a }

deriving instance MonadAsync m => Functor (AsynclyT m)
deriving instance MonadAsync m => Applicative (AsynclyT m)
deriving instance MonadAsync m => Alternative (AsynclyT m)
deriving instance MonadAsync m => Monad (AsynclyT m)
deriving instance MonadAsync m => MonadIO (AsynclyT m)
instance MonadTrans (AsynclyT) where
    lift mx = AsynclyT $ AsyncT $ \s k -> lift mx >>= (\a -> (k a Nothing))

getContext :: Maybe (IORef [Recording]) -> IO Context
getContext lref = do
    childChan  <- atomically newTChan
    pendingRef <- newIORef []
    credit     <- newIORef maxBound
    return $ initContext childChan pendingRef credit lref

-- | Run an 'AsyncT m' computation, wait for it to finish and discard the
-- results.
{-# SPECIALIZE wait_ :: AsynclyT IO a -> IO () #-}
wait_ :: forall m a. (MonadAsync m, MonadCatch m) => AsynclyT m a -> m ()
wait_ (AsynclyT m) = do
    ctx <- liftIO $ getContext Nothing
    _ <- runStateT (run m) ctx
    return ()

    where

    run m = (runAsyncT m) (return ())
        (\a r -> maybe (return ()) (\x -> run x) r)

data Step a r = Stop | Done a | Yield a r

{-# SPECIALIZE wait :: AsynclyT IO a -> IO [a] #-}
{-# INLINE wait #-}
wait :: forall m a. (MonadAsync m, MonadCatch m) => AsynclyT m a -> m [a]
wait (AsynclyT m) = liftIO (getContext Nothing) >>= run m

    where

    run ma ctx = do
        (res, ctx') <- runStateT ((runAsyncT ma) (return Stop)
            (\a r -> maybe (return (Done a)) (\x -> return $ Yield a x) r)) ctx
        case res of
            Yield x mb -> liftM (x :) (run mb ctx')
            -- XXX pull from children here
            Stop -> return []
            Done x -> return (x : [])

-- scatter
{-# SPECIALIZE each :: [a] -> AsynclyT IO a #-}
each :: (MonadIO m, MonadBaseControl IO m, MonadThrow m)
    => [a] -> AsynclyT m a
each xs = foldr (<|>) empty $ map return xs

------------------------------------------------------------------------------
-- Controlling thread quota
------------------------------------------------------------------------------

-- | Runs a computation under a given thread limit.  A limit of 0 means all new
-- tasks start synchronously in the current thread unless overridden by
-- 'async'.
-- threads :: MonadAsync m => Int -> AsynclyT m a -> AsynclyT m a
-- threads n action = AsynclyT $ AsyncT $ threadCtl n (runAsyncT $ runAsynclyT action)

{-
wait_ :: AsyncT IO a -> IO ()
wait_ m =  do
    ctx <- liftIO $ getContext (return :: a -> AsyncT IO a) Nothing
    _ <- runStateT (run m) ctx
    return ()

    where

    run m = runAsyncT m >>= \x ->
        case x of
            Yield _ r -> run r
            -- XXX pull from children here
            _ -> return ()

wait :: forall m a. (MonadAsync m, MonadCatch m) => AsyncT m a -> m [a]
wait m = liftIO (getContext (return :: a -> AsyncT m a) Nothing) >>= run m

    where

    run ma ctx = do
        (a, ctx') <- runStateT (runAsyncT ma) ctx
        case a of
            Yield x mb -> liftM (x :) (run mb ctx')
            -- XXX pull from children here
            Stop -> return []
-}

{-
------------------------------------------------------------------------------
-- Running the monad
------------------------------------------------------------------------------

-- | Run an 'AsyncT m' computation and collect the results generated by each
-- thread of the computation in a list.
{-# SPECIALIZE waitAsync :: (a -> StateT Context IO (Maybe a))
   -> Maybe (IORef [Recording]) -> AsyncT IO a -> IO () #-}
waitAsync :: (MonadAsync m, MonadCatch m)
    => (a -> StateT Context m (Maybe a))
    -> Maybe (IORef [Recording])
    -> AsyncT m a -> m ()
waitAsync finalizer lref m = do
    childChan  <- liftIO $ atomically newTChan
    pendingRef <- liftIO $ newIORef []
    credit     <- liftIO $ newIORef maxBound

    let ctx = initContext childChan pendingRef credit finalizer lref

    r <- try $ runStateT comp ctx
    e <- handleResult ctx r
    maybe (return ()) throwM e

    where
    comp = do
        x <- runAsyncT m
        maybe (return Nothing) finalizer x

-- TBD throttling of producer based on consumption rate.

-- | Invoked to store the result of the computation in the context and finish
-- the computation when the computation is done
{-# SPECIALIZE gatherResult :: IORef [a] -> a -> StateT Context IO (Maybe a) #-}
gatherResult :: MonadAsync m => IORef [a] -> a -> StateT Context m (Maybe a)
gatherResult ref r = do
    liftIO $ atomicModifyIORefCAS ref $ \rs -> (r : rs, ())
    return Nothing

gather :: (MonadAsync m, MonadCatch m)
    => AsyncT m a
    -> StateT Context m (Maybe [a])
gather m = do
    resultsRef <- liftIO $ newIORef []
    lift $ waitAsync (gatherResult resultsRef) Nothing m
    r <- liftIO $ readIORef resultsRef
    return $ Just r

-- | Run an 'AsyncT m' computation and collect the results generated by each
-- thread of the computation in a list.
{-# SPECIALIZE wait :: AsyncT IO a -> IO [a] #-}
wait :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m [a]
wait m = do
    resultsRef <- liftIO $ newIORef []
    waitAsync (gatherResult resultsRef) Nothing m
    liftIO $ readIORef resultsRef

-- | Run an 'AsyncT m' computation, wait for it to finish and discard the
-- results.
wait_ :: (MonadAsync m, MonadCatch m) => AsyncT m a -> m ()
wait_ m = waitAsync (const (return Nothing)) Nothing m

------------------------------------------------------------------------------
-- Logging
------------------------------------------------------------------------------

-- | Compose a computation using previously captured logs
playRecording :: (MonadAsync m, MonadRecorder m)
    => AsyncT m a -> Recording -> AsyncT m a
playRecording m recording = play recording >> m

-- | Resume an 'AsyncT' computation using previously recorded logs. The
-- recording consists of a list of journals one for each thread in the
-- computation.
playRecordings :: (MonadAsync m, MonadRecorder m)
    => AsyncT m a -> [Recording] -> AsyncT m a
playRecordings m logs = each logs >>= playRecording m

-- | Run an 'AsyncT' computation with recording enabled, wait for it to finish
-- returning results for completed threads and recordings for paused threads.
waitRecord :: (MonadAsync m, MonadCatch m)
    => AsyncT m a -> m ([a], [Recording])
waitRecord m = do
    resultsRef <- liftIO $ newIORef []
    lref <- liftIO $ newIORef []
    waitAsync (gatherResult resultsRef) (Just lref) m
    res <- liftIO $ readIORef resultsRef
    logs <- liftIO $ readIORef lref
    return (res, logs)

-- | Run an 'AsyncT' computation with recording enabled, wait for it to finish
-- and discard the results and return the recordings for paused threads, if
-- any.
waitRecord_ :: (MonadAsync m, MonadCatch m)
    => AsyncT (RecorderT m) a -> m [Recording]
waitRecord_ m = do
    lref <- liftIO $ newIORef []
    runRecorderT blank (waitAsync (const (return Nothing)) (Just lref) m)
    logs <- liftIO $ readIORef lref
    return logs

-}
