{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

-- |
-- Module      : Asyncly.RunAsync
-- Copyright   : (c) 2017 Harendra Kumar
--
-- License     : MIT-style
-- Maintainer  : harendra.kumar@gmail.com
-- Stability   : experimental
-- Portability : GHC
--
module Asyncly.RunAsync
    ( runAsyncly
    , toList
    , each
    , for
    , runAsynclyRecorded
--    , toListRecorded
    , playRecordings
    )
where

import           Control.Applicative         (Alternative (..))
import           Control.Monad               (liftM)
import           Control.Monad.Catch         (MonadThrow)
import           Control.Monad.IO.Class      (MonadIO (..))
import           Control.Monad.Trans.Class   (MonadTrans (lift))
import           Control.Monad.State         (StateT(..), runStateT)
import           Data.Monoid                 ((<>))
import           Data.IORef                  (IORef, newIORef, readIORef)

import           Control.Monad.Trans.Recorder (MonadRecorder(..), RecorderT,
                                               Recording, blank, runRecorderT)
import           Asyncly.AsyncT

------------------------------------------------------------------------------
-- Running the monad
------------------------------------------------------------------------------

-- | Run an 'AsyncT m' computation, wait for it to finish and discard the
-- results.
{-# INLINABLE runAsynclyLogged #-}
runAsynclyLogged :: MonadAsync m
    => Maybe (IORef [Recording]) -> AsyncT m a -> m ()
runAsynclyLogged lref m = run Nothing m

    where

    stop = return ()

    {-# INLINE yield #-}
    yield _ _ Nothing  = stop
    yield _ c (Just x) = run c x

    run ct mx = (runAsyncT mx) ct stop yield

runAsyncly :: MonadAsync m => AsyncT m a -> m ()
runAsyncly m = runAsynclyLogged Nothing m

-- | Run an 'AsyncT m' computation and collect the results generated by each
-- thread of the computation in a list.
{-# INLINABLE toList #-}
toList :: MonadAsync m => AsyncT m a -> m [a]
toList m = run Nothing m

    where

    stop = return []

    {-# INLINE yield #-}
    yield a _ Nothing  = return [a]
    yield a c (Just x) = liftM (a :) (run c x)

    {-# INLINE run #-}
    run ctx mx = (runAsyncT mx) ctx stop yield

-- | Run a given function concurrently on the list and collect the results.
{-# INLINABLE for #-}
for :: MonadAsync m => [a] -> (a -> AsyncT m b) -> AsyncT m b
for xs f = foldr (<|>) empty $ map f xs

-- XXX rename to fromList?
{-# INLINABLE each #-}
each :: MonadAsync m => [a] -> AsyncT m a
each xs = foldr (<>) empty $ map return xs

------------------------------------------------------------------------------
-- Logging
------------------------------------------------------------------------------

-- | Compose a computation using previously captured logs
playRecording :: (MonadAsync m, MonadRecorder m)
    => AsyncT m a -> Recording -> AsyncT m a
playRecording m recording = play recording >> m

-- | Resume an 'AsyncT' computation using previously recorded logs. The
-- recording consists of a list of journals one for each thread in the
-- computation.
playRecordings :: (MonadAsync m, MonadRecorder m)
    => AsyncT m a -> [Recording] -> AsyncT m a
playRecordings m logs = each logs >>= playRecording m

{-
-- | Run an 'AsyncT' computation with recording enabled, wait for it to finish
-- returning results for completed threads and recordings for paused threads.
toListRecorded :: (MonadAsync m, MonadCatch m)
    => AsyncT m a -> m ([a], [Recording])
toListRecorded m = do
    resultsRef <- liftIO $ newIORef []
    lref <- liftIO $ newIORef []
    waitAsync (gatherResult resultsRef) (Just lref) m
    res <- liftIO $ readIORef resultsRef
    logs <- liftIO $ readIORef lref
    return (res, logs)
    -}

-- | Run an 'AsyncT' computation with recording enabled, wait for it to finish
-- and discard the results and return the recordings for paused threads, if
-- any.
runAsynclyRecorded :: MonadAsync m => AsyncT (RecorderT m) a -> m [Recording]
runAsynclyRecorded m = do
    lref <- liftIO $ newIORef []
    runRecorderT blank (runAsynclyLogged (Just lref) m)
    logs <- liftIO $ readIORef lref
    return logs
